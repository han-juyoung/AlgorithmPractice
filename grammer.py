# a, b = map(int, input().split())
# lst = list(map(int, input().split()))

# arr.sort()
# arr.sort(reverse=True)

# s = "hello"
# s.upper() 
# s.lower()
# s[::-1]
# ''.join(list)

# if x==1:
# elif x>=2:
# else:

# for i in range(n):

# while True:

# lst = [1, 2, 3]
# lst.append(4)
# lst.pop()
# lst.remove(2)
# lst.index(3)

# d = {'a':1, 'b':2}
# d['c'] = 3
# d.keys(), d.values(), d.items()

# s1 = {1,2,3}
# s2 = {3,4,5,}
# s1|s2
# s1&s2
# s1-s2

# from collections import deque
# stack = []
# stack.append()
# stack.pop()

# queue = deque([1,2,3])
# queue.append(4)
# queue.popleft()

# arr = [(1,3), (2,2), (3,1)]
# arr.sort(key=lambda x: x[1])

# from bisect import bisect_left, bisect_right
# bisect_left(arr, x)
# bisect_right(arr, x)

# # dfs
# def dfs(x, y):
#     if visited[x][y]:
#         return
#     visited[x][y] = True
#     for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
#         dfs(x+dx, y+dy)

# # bfs
# from collections import deque
# def bfs(x, y):
#     q = deque([x, y])
#     visited[x][y] = True
#     while q:
#         cx, cy = q.popleft()
#         for dx, dy in [(1,0), (-1,0), (0,1), (0, -1)]:
#             nx, ny = cx + dx, cy+dy
#             if not visited([nx][ny]):
#                 q.append((nx, ny))
#                 visited[nx][ny] = True



